<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <title>共同制作ツール</title>
    <style>
        /* --- 全体基本スタイル --- */
        body {
            font-family: Arial, sans-serif;
            margin: 20px;
            background-color: #f4f4f4;
            color: #333;
        }
        h1 {
            color: #4CAF50;
        }
        .container {
            max-width: 1200px;
            margin: auto;
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
        }
        
        /* --- 起動制御画面のスタイル --- */
        #setup-screen {
            padding: 30px;
            border: 2px solid #ccc;
            border-radius: 8px;
            text-align: center;
            margin-bottom: 20px;
            background-color: #e8f5e9;
        }
        #setup-screen input[type="text"] {
            padding: 10px;
            width: 80%;
            max-width: 300px;
            margin: 10px 0 20px;
            border: 1px solid #ccc;
            border-radius: 4px;
        }
        #setup-screen button {
            padding: 10px 20px;
            background-color: #4CAF50;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 16px;
            transition: background-color 0.3s;
        }
        #setup-screen button:hover {
            background-color: #45a049;
        }

        /* --- メイン画面共通スタイル --- */
        #main-content {
            display: none;
        }
        .user-info {
            background-color: #e8f5e9;
            padding: 10px;
            border-radius: 4px;
            margin-bottom: 15px;
            border-left: 5px solid #4CAF50;
        }
        .user-info label {
            font-weight: bold;
            color: #2e7d32;
        }
        .user-info span {
            margin-right: 15px;
            font-weight: normal;
        }
        
        /* --- ルーム切り替えボタンのスタイル (追加) --- */
        .room-switch-button {
            padding: 5px 10px;
            border: 1px solid #4CAF50;
            background-color: white;
            color: #4CAF50;
            cursor: pointer;
            border-radius: 4px;
            transition: all 0.2s;
            margin-right: 5px;
        }
        .room-switch-button.active-room {
            background-color: #4CAF50;
            color: white;
            font-weight: bold;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
        }

        /* --- 描画ツールのコントロール群のスタイル --- */
        #drawing-controls {
            display: none; /* 初期は非表示 */
            flex-wrap: wrap;
            gap: 10px;
            margin-bottom: 10px;
            padding: 10px;
            background-color: #f0f0f0;
            border-radius: 4px;
            align-items: center;
        }
        .controls {
            display: flex;
            gap: 10px;
            align-items: center;
        }
        .controls input[type="color"], .controls input[type="number"] {
            padding: 5px;
            border: 1px solid #ccc;
            border-radius: 4px;
        }
        .controls button {
            padding: 8px 15px;
            background-color: #4a86f7;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            transition: background-color 0.3s;
        }
        .controls button:hover {
            background-color: #3b73e8;
        }

        /* --- 描画ルームのスタイル --- */
        #drawing-room {
            display: none; /* 初期は非表示 */
        }
        #drawing-room-content {
            border: 1px solid #ccc;
            background-color: #fff;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
            position: relative; /* カーソル表示の基準 */
        }
        #drawingCanvas {
            display: block;
        }
        .remote-cursor-drawing {
            position: absolute;
            width: 20px;
            height: 20px;
            border: 2px solid red;
            border-radius: 50%;
            pointer-events: none;
            transition: transform 0.1s linear;
            z-index: 1000;
        }
        .cursor-nickname {
            position: absolute;
            top: -15px;
            left: 20px;
            background-color: red;
            color: white;
            padding: 2px 5px;
            border-radius: 3px;
            font-size: 10px;
            white-space: nowrap;
        }

        /* --- 小説/音楽ルームのスタイル --- */
        #novel-room, #music-room {
            display: none; /* 初期は非表示 */
        }
        .textarea-container {
            position: relative;
        }
        textarea {
            width: 100%;
            height: 500px;
            padding: 10px;
            border: 1px solid #ccc;
            border-radius: 4px;
            box-sizing: border-box;
            font-size: 16px;
            line-height: 1.6;
            resize: none;
        }
        .remote-cursor-text {
            position: absolute;
            width: 2px;
            background-color: red;
            pointer-events: none;
            animation: blink 1s infinite;
            z-index: 1000;
        }
        .remote-cursor-text .cursor-nickname {
            top: -18px;
            left: 5px;
            background-color: red;
        }
        @keyframes blink {
            0%, 100% { opacity: 1; }
            50% { opacity: 0; }
        }

        /* --- 音楽ルーム固有のスタイル --- */
        .music-url-list {
            margin-top: 10px;
            padding: 10px;
            border: 1px dashed #4CAF50;
            border-radius: 4px;
            background-color: #f9f9f9;
        }
        .music-url-list p {
            margin: 5px 0;
            padding: 3px 5px;
            background-color: #e8f5e9;
            border-left: 3px solid #4CAF50;
        }

        /* --- 作品公開フォームのスタイル --- */
        #publish-work-form {
            margin-top: 20px;
            padding: 15px;
            border: 1px solid #4CAF50;
            border-radius: 8px;
            background-color: #e8f5e9;
        }
        #publish-work-form input[type="text"] {
            padding: 8px;
            width: 300px;
            margin-right: 10px;
            border: 1px solid #ccc;
            border-radius: 4px;
        }
        #publish-work-form button {
            padding: 8px 15px;
            background-color: #ff9800;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            transition: background-color 0.3s;
        }
        #publish-work-form button:hover {
            background-color: #e68900;
        }
        #publishStatus {
            margin-top: 10px;
            font-weight: bold;
        }

    </style>
</head>
<body>

    <div class="container">
        <h1>共同制作ツール</h1>

        <p><a href="published.html" target="_blank">公開作品一覧を見る</a></p>

        <div id="setup-screen">
            <h2>参加設定</h2>
            <p>共同作業を始めるために、ニックネームと参加ルームを選択してください。</p>
            <input type="text" id="nicknameInput" placeholder="ニックネームを入力" maxlength="10">
            <div>
                <label for="initialRoomSelect">ルーム選択:</label>
                <select id="initialRoomSelect">
                    <option value="free">フリールーム (お絵かき)</option>
                    <option value="novel">小説ルーム (テキスト)</option>
                    <option value="music">音楽ルーム (テキスト/URL)</option>
                </select>
            </div>
            <button id="joinButton">参加</button>
        </div>

        <div id="main-content">
            <div class="user-info">
                <label>現在のルーム:</label>
                <span id="currentRoomDisplay"></span>
                <label style="margin-left: 20px;">現在のニックネーム:</label>
                <span id="currentNicknameDisplay"></span>
                
                <div id="runtime-room-selection" style="display: inline-block; margin-left: 20px;">
                    <button data-room="free" class="room-switch-button">フリールーム</button>
                    <button data-room="novel" class="room-switch-button">小説ルーム</button>
                    <button data-room="music" class="room-switch-button">音楽ルーム</button>
                </div>
            </div>

            <div id="online-users" style="margin-bottom: 15px;">
                <strong>オンライン: </strong><span id="user-list"></span>
            </div>

            <div id="drawing-room">
                <h2>フリールーム (お絵かき)</h2>
                <div id="drawing-controls">
                    <div class="controls">
                        <label for="colorPicker">色:</label>
                        <input type="color" id="colorPicker" value="#ff0000">
                    </div>
                    <div class="controls">
                        <label for="lineWidthRange">太さ:</label>
                        <input type="range" id="lineWidthRange" min="1" max="50" value="5">
                        <span id="lineWidthDisplay">5</span>px
                    </div>
                    <div class="controls">
                        <button id="eraseButton">消しゴム</button>
                        <button id="clearButton">全消去</button>
                        <button id="undoButton" disabled>元に戻す</button>
                        <button id="redoButton" disabled>やり直す</button>
                    </div>
                </div>
                <div id="drawing-room-content">
                    <canvas id="drawingCanvas"></canvas>
                    </div>
            </div>

            <div id="novel-room">
                <h2>小説ルーム</h2>
                <div class="textarea-container">
                    <textarea id="novelTextarea" placeholder="ここに共同で小説を入力してください。" spellcheck="false"></textarea>
                    </div>
            </div>

            <div id="music-room">
                <h2>音楽ルーム (歌詞/アイデア)</h2>
                <p>歌詞やアイデア、楽譜へのURLなどを共同で入力できます。URLは `[URL: http://example.com/score]` の形式で記載してください。</p>
                <div class="music-url-list">
                    <strong>関連URL一覧:</strong>
                    <div id="music-url-display"></div>
                </div>
                <div class="textarea-container">
                    <textarea id="lyricsTextarea" placeholder="ここに共同で歌詞やアイデアを入力してください。" spellcheck="false"></textarea>
                    </div>
            </div>

            <div id="publish-work-form">
                <h3>作品公開</h3>
                <input type="text" id="workTitleInput" placeholder="作品タイトルを入力" maxlength="50">
                <button id="publishButton">公開</button>
                <div id="publishStatus"></div>
            </div>

        </div>
    </div>

    <script>
        // =========================================================================================
        // 初期設定
        // =========================================================================================

        let ws;
        let nickname = '';
        let currentRoom = '';
        let history = []; // 描画履歴
        let historyIndex = -1; // 現在の履歴位置

        // 【重要】DOM操作に必要な要素の取得
        const setupScreen = document.getElementById('setup-screen');
        const mainContent = document.getElementById('main-content');
        const nicknameInput = document.getElementById('nicknameInput');
        const initialRoomSelect = document.getElementById('initialRoomSelect');
        const joinButton = document.getElementById('joinButton');
        const currentRoomDisplay = document.getElementById('currentRoomDisplay');
        const currentNicknameDisplay = document.getElementById('currentNicknameDisplay');
        
        // ★★★ 表示制御対象のルーム要素定数 ★★★
        const drawingRoom = document.getElementById('drawing-room');
        const novelRoom = document.getElementById('novel-room');
        const musicRoom = document.getElementById('music-room');
        const drawingControls = document.getElementById('drawing-controls'); // 描画コントロール
        
        // ★★★ 追加: ルーム要素のマップ (確実にすべてを制御するため) ★★★
        const roomElements = {
            'free': drawingRoom,
            'novel': novelRoom,
            'music': musicRoom
        };

        const novelTextarea = document.getElementById('novelTextarea');
        const lyricsTextarea = document.getElementById('lyricsTextarea');
        
        const roomSwitchButtons = document.querySelectorAll('.room-switch-button');

        const drawingRoomContent = document.getElementById('drawing-room-content');
        const drawingCanvas = document.getElementById('drawingCanvas');
        const ctx = drawingCanvas.getContext('2d');
        
        const musicUrlDisplay = document.getElementById('music-url-display');
        
        const publishButton = document.getElementById('publishButton');
        const workTitleInput = document.getElementById('workTitleInput');
        const publishStatus = document.getElementById('publishStatus');

        let isDrawing = false;
        let lastX = 0;
        let lastY = 0;
        let musicUrls = [];
        
        // リモートカーソル管理マップ
        const remoteCursors = new Map();

        // 描画キャンバスのサイズ設定
        drawingCanvas.width = 800;
        drawingCanvas.height = 500;
        
        // 初期背景を白に設定
        ctx.fillStyle = 'white';
        ctx.fillRect(0, 0, drawingCanvas.width, drawingCanvas.height);
        
        // 描画設定の初期値
        let currentColor = document.getElementById('colorPicker').value;
        let currentLineWidth = parseInt(document.getElementById('lineWidthRange').value);
        let isErasing = false;

        // =========================================================================================
        // ユーティリティ関数
        // =========================================================================================

        /**
         * ルーム名表示用
         */
        function getRoomName(room) {
            switch(room) {
                case 'free': return 'フリールーム (お絵かき)';
                case 'novel': return '小説ルーム';
                case 'music': return '音楽ルーム';
                default: return '不明';
            }
        }
        
        /**
         * ルームの初期コンテンツをロードし、表示を切り替える (再々最適化)
         */
        async function loadInitialContent(room) {
            // 1. すべてのルームを確実に非表示にする
            Object.keys(roomElements).forEach(key => {
                roomElements[key].style.display = 'none';
            });
            drawingControls.style.display = 'none'; // 描画コントロールはfree専用なので別途非表示

            // 2. 選択されたルームのみ表示し、コンテンツをロード
            if (room === 'free') {
                drawingRoom.style.display = 'block';
                drawingControls.style.display = 'flex'; // 描画コントロールを表示
                await loadDrawing();
            } else if (room === 'novel') {
                novelRoom.style.display = 'block';
                novelTextarea.value = await loadTextData('novel');
            } else if (room === 'music') {
                musicRoom.style.display = 'block';
                const loadedData = await loadTextData('music');
                const [lyrics, urls] = parseMusicData(loadedData);
                lyricsTextarea.value = lyrics;
                musicUrls = urls;
                renderMusicUrls();
            }
        }

        /**
         * テキストデータ取得
         */
        async function loadTextData(room) {
            try {
                const res = await fetch(`/api/content/${room}`);
                if (res.ok) {
                    const data = await res.json();
                    return data.content;
                }
            } catch (error) {
                console.error(`Error loading ${room} content:`, error);
            }
            return ''; // エラー時は空文字を返す
        }
        
        /**
         * 描画データ取得
         */
        async function loadDrawing() {
            try {
                const res = await fetch('/api/content/free');
                if (res.ok) {
                    const data = await res.json();
                    if (data.content && data.content.history) {
                        history = data.content.history;
                        historyIndex = history.length - 1;
                        redrawCanvas();
                        updateUndoRedoButtons();
                    } else {
                        // データがない場合は初期化
                        ctx.fillStyle = 'white';
                        ctx.fillRect(0, 0, drawingCanvas.width, drawingCanvas.height);
                        history = [];
                        historyIndex = -1;
                        updateUndoRedoButtons();
                    }
                }
            } catch (error) {
                console.error('Error loading drawing content:', error);
            }
        }
        
        /**
         * 音楽データのURLをパース
         */
        function parseMusicData(data) {
            const urlRegex = /\[URL: (.*?)\]/g;
            const urls = [];
            let match;
            
            // 歌詞/アイデア部分だけを抽出するためにURL行を削除
            let lyrics = data.replace(urlRegex, '').trim();
            
            // 再度全体からURLを抽出
            let temp = data;
            while ((match = urlRegex.exec(temp)) !== null) {
                urls.push(match[1]);
            }
            
            return [lyrics, urls];
        }

        /**
         * 音楽URLリストをHTMLで表示
         */
        function renderMusicUrls() {
            musicUrlDisplay.innerHTML = '';
            if (musicUrls.length === 0) {
                musicUrlDisplay.innerHTML = '<p style="color: #666;">まだURLは登録されていません。</p>';
                return;
            }
            musicUrls.forEach(url => {
                const p = document.createElement('p');
                const a = document.createElement('a');
                a.href = url;
                a.textContent = url;
                a.target = '_blank';
                p.appendChild(a);
                musicUrlDisplay.appendChild(p);
            });
        }
        
        // =========================================================================================
        // WebSocket通信
        // =========================================================================================

        /**
         * WebSocketの初期化と接続処理
         */
        function initializeWebSocket(room) {
            currentRoom = room;

            // 以下のホスト名をRenderで割り当てられた公開アドレスに書き換えてください。
            ws = new WebSocket('wss://co-production.onrender.com'); // ★Placeholder: 実際のホスト名に変更が必要★

            ws.onopen = () => {
                console.log('WebSocket connection established.');
                sendJoinRoom(room);
            };

            ws.onmessage = (event) => {
                const data = JSON.parse(event.data);
                handleMessage(data);
            };

            ws.onclose = () => {
                console.log('WebSocket connection closed. Attempting to reconnect...');
                setTimeout(() => initializeWebSocket(currentRoom), 5000); // 5秒後に再接続を試みる
            };

            ws.onerror = (error) => {
                console.error('WebSocket error:', error);
            };
        }
        
        /**
         * ルーム参加メッセージの送信
         */
        function sendJoinRoom(room) {
            ws.send(JSON.stringify({
                type: 'join',
                room: room,
                nickname: nickname
            }));
        }

        /**
         * 描画イベントの送信
         */
        function sendDrawing(x0, y0, x1, y1, color, lineWidth, isErase) {
            ws.send(JSON.stringify({
                type: 'draw',
                room: 'free',
                x0, y0, x1, y1, color, lineWidth, isErase
            }));
        }

        /**
         * テキスト更新イベントの送信
         */
        function sendTextUpdate(text, room) {
            ws.send(JSON.stringify({
                type: 'text_update',
                room: room,
                content: text
            }));
        }
        
        /**
         * カーソル位置更新の送信
         */
        function sendCursorUpdate(isText, position) {
            ws.send(JSON.stringify({
                type: 'cursor_update',
                room: currentRoom,
                isText: isText,
                position: position // {x, y} for drawing, index for text
            }));
        }
        
        /**
         * メッセージハンドラ
         */
        function handleMessage(data) {
            switch (data.type) {
                case 'joined':
                    updateUserList(data.users);
                    break;
                case 'user_list_update':
                    updateUserList(data.users);
                    break;
                case 'draw':
                    if (data.room === 'free') {
                        drawLine(data.x0, data.y0, data.x1, data.y1, data.color, data.lineWidth, data.isErase);
                    }
                    break;
                case 'text_update':
                    if (data.room === 'novel' && data.content !== novelTextarea.value) {
                        novelTextarea.value = data.content;
                    } else if (data.room === 'music' && data.content !== lyricsTextarea.value) {
                        const [lyrics, urls] = parseMusicData(data.content);
                        lyricsTextarea.value = lyrics;
                        musicUrls = urls;
                        renderMusicUrls();
                    }
                    break;
                case 'clear':
                    if (data.room === 'free') {
                        clearCanvas();
                        history = [];
                        historyIndex = -1;
                        updateUndoRedoButtons();
                    }
                    break;
                case 'undo_redo':
                    if (data.room === 'free') {
                        history = data.history;
                        historyIndex = data.historyIndex;
                        redrawCanvas();
                        updateUndoRedoButtons();
                    }
                    break;
                case 'cursor_update':
                    updateRemoteCursor(data);
                    break;
                default:
                    console.log('Received unknown message type:', data.type);
            }
        }
        
        /**
         * オンラインユーザーリストの更新
         */
        function updateUserList(users) {
            const userListElement = document.getElementById('user-list');
            userListElement.textContent = users.join(', ');
        }
        
        // =========================================================================================
        // 描画ルームのロジック
        // =========================================================================================

        /**
         * 描画処理 (ライン)
         */
        function drawLine(x0, y0, x1, y1, color, lineWidth, isErase, addToHistory = false) {
            ctx.beginPath();
            ctx.strokeStyle = color;
            ctx.lineWidth = lineWidth;
            ctx.lineCap = 'round';
            ctx.globalCompositeOperation = isErase ? 'destination-out' : 'source-over';
            ctx.moveTo(x0, y0);
            ctx.lineTo(x1, y1);
            ctx.stroke();

            // 履歴に追加 (ローカル操作の場合のみ)
            if (addToHistory) {
                const drawData = { x0, y0, x1, y1, color, lineWidth, isErase };
                // undo後に新しい描画をした場合、それ以降の履歴を消す
                if (historyIndex < history.length - 1) {
                    history.splice(historyIndex + 1);
                }
                history.push(drawData);
                historyIndex = history.length - 1;
                updateUndoRedoButtons();
            }
        }
        
        /**
         * キャンバス全消去
         */
        function clearCanvas() {
            ctx.globalCompositeOperation = 'source-over';
            ctx.fillStyle = 'white';
            ctx.fillRect(0, 0, drawingCanvas.width, drawingCanvas.height);
        }

        /**
         * 履歴に基づいてキャンバスを再描画
         */
        function redrawCanvas() {
            clearCanvas();
            for (let i = 0; i <= historyIndex; i++) {
                const data = history[i];
                drawLine(data.x0, data.y0, data.x1, data.y1, data.color, data.lineWidth, data.isErase);
            }
        }
        
        /**
         * 元に戻す/やり直しのボタン状態更新
         */
        function updateUndoRedoButtons() {
            document.getElementById('undoButton').disabled = historyIndex < 0;
            document.getElementById('redoButton').disabled = historyIndex >= history.length - 1;
        }

        // =========================================================================================
        // リモートカーソル管理
        // =========================================================================================

        /**
         * リモートカーソルを更新
         */
        function updateRemoteCursor(data) {
            if (data.nickname === nickname) return; // 自分のカーソルは無視

            let cursorDiv = remoteCursors.get(data.nickname);
            
            // カーソル要素がまだない場合は作成
            if (!cursorDiv) {
                cursorDiv = createCursorElement(data.nickname);
                remoteCursors.set(data.nickname, cursorDiv);
            }

            // 自分のルームと一致しない、または非表示が指示された場合
            if (data.room !== currentRoom || (data.isText && data.position === -1) || (!data.isText && data.position.x === -1)) {
                 // 非表示に設定
                cursorDiv.style.display = 'none';
                return;
            }
            
            // 自分のルームと一致し、カーソルがある場合
            cursorDiv.style.display = 'block';
            
            if (data.isText) {
                // テキストカーソルの処理 (novel/musicルーム)
                cursorDiv.className = 'remote-cursor-text';
                const textarea = data.room === 'novel' ? novelTextarea : lyricsTextarea;
                positionTextCursor(cursorDiv, textarea, data.position);
            } else {
                // 描画カーソルの処理 (freeルーム)
                cursorDiv.className = 'remote-cursor-drawing';
                // 描画ルームの親要素に移動（もし別のルームから来た場合）
                if (cursorDiv.parentNode !== drawingRoomContent) {
                    drawingRoomContent.appendChild(cursorDiv);
                }
                cursorDiv.style.transform = `translate(${data.position.x - 10}px, ${data.position.y - 10}px)`;
            }
        }
        
        /**
         * カーソル要素を生成
         */
        function createCursorElement(name) {
            const div = document.createElement('div');
            const nicknameSpan = document.createElement('span');
            nicknameSpan.className = 'cursor-nickname';
            nicknameSpan.textContent = name;
            div.appendChild(nicknameSpan);
            
            // ひとまず描画ルーム用として作成
            drawingRoomContent.appendChild(div);
            
            return div;
        }
        
        /**
         * テキストエリア内のカーソル位置を計算し、カーソル要素を配置
         */
        function positionTextCursor(cursorDiv, textarea, position) {
            const textareaContainer = textarea.closest('.textarea-container');
            
            // 親要素が異なる場合は移動させる
            if (cursorDiv.parentNode !== textareaContainer) {
                textareaContainer.appendChild(cursorDiv);
            }
            
            // テキストカーソル位置計算
            const preText = textarea.value.substring(0, position);
            
            const measureSpan = document.createElement('span');
            measureSpan.style.whiteSpace = 'pre-wrap';
            measureSpan.style.font = window.getComputedStyle(textarea).font;
            measureSpan.style.position = 'absolute';
            measureSpan.style.visibility = 'hidden';
            measureSpan.style.width = textarea.clientWidth + 'px';
            measureSpan.style.padding = window.getComputedStyle(textarea).padding;
            
            // カーソル前のテキストとカーソルをシミュレートする要素
            measureSpan.innerHTML = preText.replace(/\n/g, '<br>') + '<span id="cursor-pos-measure">|</span>';
            
            document.body.appendChild(measureSpan);
            
            const cursorMeasure = document.getElementById('cursor-pos-measure');
            if (cursorMeasure) {
                const rect = cursorMeasure.getBoundingClientRect();
                const textareaRect = textarea.getBoundingClientRect();
                
                // textareaのパディングなどを考慮して相対座標に変換
                const x = rect.left - textareaRect.left + textarea.scrollLeft;
                const y = rect.top - textareaRect.top + textarea.scrollTop + 2; // +2は調整
                
                cursorDiv.style.transform = `translate(${x}px, ${y}px)`;
                cursorDiv.style.height = window.getComputedStyle(textarea).lineHeight;
            }
            
            document.body.removeChild(measureSpan);
        }

        // =========================================================================================
        // イベントリスナー設定
        // =========================================================================================
        
        /**
         * 起動ボタンのクリックイベント
         */
        joinButton.addEventListener('click', () => {
            const initialNickname = nicknameInput.value.trim();
            const initialRoom = initialRoomSelect.value;
            
            if (initialNickname && initialNickname.length <= 10) {
                nickname = initialNickname;
                currentRoom = initialRoom;

                currentNicknameDisplay.textContent = nickname;
                currentRoomDisplay.textContent = getRoomName(currentRoom);
                
                setupScreen.style.display = 'none';
                mainContent.style.display = 'block';

                initializeWebSocket(initialRoom);
                loadInitialContent(initialRoom);
                updateRoomSwitchButtons(initialRoom);
            } else {
                alert('ニックネームは1〜10文字で入力してください。');
            }
        });
        
        /**
         * ルーム切り替えボタンのイベントリスナー
         */
        roomSwitchButtons.forEach(button => {
            button.addEventListener('click', (e) => {
                const newRoom = e.target.dataset.room;
                if (newRoom !== currentRoom) {
                    // カーソル非表示を送信
                    sendCursorUpdate(true, -1); 
                    sendCursorUpdate(false, {x: -1, y: -1});
                    
                    currentRoom = newRoom;
                    currentRoomDisplay.textContent = getRoomName(currentRoom);
                    
                    // WebSocketのルーム変更とコンテンツ/カーソルのリロード
                    sendJoinRoom(newRoom);
                    loadInitialContent(newRoom);
                    
                    // ボタンのアクティブ状態を更新
                    updateRoomSwitchButtons(newRoom);
                }
            });
        });

        /**
         * ボタンのアクティブ状態を管理する関数
         */
        function updateRoomSwitchButtons(activeRoom) {
            roomSwitchButtons.forEach(button => {
                if (button.dataset.room === activeRoom) {
                    button.classList.add('active-room');
                } else {
                    button.classList.remove('active-room');
                }
            });
        }

        // --- 描画イベント ---
        drawingCanvas.addEventListener('mousedown', (e) => {
            if (currentRoom !== 'free') return;
            isDrawing = true;
            [lastX, lastY] = [e.offsetX, e.offsetY];
            // クリック時も点として描画履歴に残す
            drawLine(lastX, lastY, lastX, lastY, currentColor, currentLineWidth, isErasing, true);
            sendDrawing(lastX, lastY, lastX, lastY, currentColor, currentLineWidth, isErasing);
        });

        drawingCanvas.addEventListener('mousemove', (e) => {
            // 現在のルームがfreeの場合でも、カーソル位置は常に送信
            const position = {x: e.offsetX, y: e.offsetY};
            sendCursorUpdate(false, position);

            if (currentRoom !== 'free' || !isDrawing) return;
            
            drawLine(lastX, lastY, e.offsetX, e.offsetY, currentColor, currentLineWidth, isErasing, true);
            sendDrawing(lastX, lastY, e.offsetX, e.offsetY, currentColor, currentLineWidth, isErasing);
            
            [lastX, lastY] = [e.offsetX, e.offsetY];
        });

        drawingCanvas.addEventListener('mouseup', () => {
            isDrawing = false;
        });

        drawingCanvas.addEventListener('mouseout', () => {
            isDrawing = false;
            // カーソルを非表示に
            if (currentRoom === 'free') {
                sendCursorUpdate(false, {x: -1, y: -1});
            }
        });
        
        // --- 描画コントロール ---
        document.getElementById('colorPicker').addEventListener('input', (e) => {
            currentColor = e.target.value;
            isErasing = false;
            document.getElementById('eraseButton').classList.remove('active');
        });

        document.getElementById('lineWidthRange').addEventListener('input', (e) => {
            currentLineWidth = parseInt(e.target.value);
            document.getElementById('lineWidthDisplay').textContent = currentLineWidth;
        });
        
        document.getElementById('eraseButton').addEventListener('click', (e) => {
            isErasing = !isErasing;
            e.target.classList.toggle('active', isErasing);
        });

        document.getElementById('clearButton').addEventListener('click', () => {
            if (currentRoom !== 'free' || !confirm('キャンバス上のすべての内容を消去してもよろしいですか？')) return;
            
            clearCanvas();
            ws.send(JSON.stringify({ type: 'clear', room: 'free' }));
            
            // 履歴をクリア
            history = [];
            historyIndex = -1;
            updateUndoRedoButtons();
        });
        
        const redoButton = document.getElementById('redoButton');

        document.getElementById('undoButton').addEventListener('click', () => {
            if (currentRoom !== 'free' || historyIndex < 0) return;

            historyIndex--;
            // サーバーにインデックス変更を送信 (サーバー側で履歴全体を再送信させる)
            ws.send(JSON.stringify({ type: 'undo', room: 'free', historyIndex: historyIndex })); 
            redrawCanvas();
            updateUndoRedoButtons();
        });

        redoButton.addEventListener('click', () => {
            if (currentRoom !== 'free' || historyIndex >= history.length - 1) return;
            
            historyIndex++;
            // サーバーにインデックス変更を送信 (サーバー側で履歴全体を再送信させる)
            ws.send(JSON.stringify({ type: 'redo', room: 'free', historyIndex: historyIndex })); 
            redrawCanvas();
            updateUndoRedoButtons();
        });


        // --- テキストエリアのトラッキング ---
        function setupTextareaTracking(textarea, room) {
            textarea.addEventListener('input', () => {
                // テキスト変更を送信
                sendTextUpdate(textarea.value, room);
                
                // 音楽ルームの場合、URLリストも更新
                if (room === 'music') {
                    const [lyrics, urls] = parseMusicData(textarea.value);
                    musicUrls = urls;
                    renderMusicUrls();
                }
            });
            
            // カーソル位置の変更をトラッキング
            const updateCursorPosition = () => {
                if (currentRoom === room) {
                    sendCursorUpdate(true, textarea.selectionStart);
                }
            };

            textarea.addEventListener('keyup', updateCursorPosition);
            textarea.addEventListener('mouseup', updateCursorPosition);
            textarea.addEventListener('focus', updateCursorPosition); // フォーカス時にも送信

            textarea.addEventListener('mouseout', () => {
                // カーソルを非表示に
                if (currentRoom === room) {
                    sendCursorUpdate(true, -1);
                }
            });
            
            textarea.addEventListener('mouseover', updateCursorPosition);
        }

        setupTextareaTracking(novelTextarea, 'novel');
        setupTextareaTracking(lyricsTextarea, 'music');


        // --- 作品公開イベント ---
        publishButton.addEventListener('click', async () => {
            const title = workTitleInput.value.trim();
            let content = '';
            let contentType = 'text'; 

            if (!title) {
                publishStatus.textContent = 'タイトルを入力してください。';
                publishStatus.style.color = 'red';
                return;
            }

            if (currentRoom === 'free') {
                content = drawingCanvas.toDataURL('image/png');
                contentType = 'image';
            } else if (currentRoom === 'novel') {
                content = `作者: ${nickname}\n\n${novelTextarea.value}`;
                contentType = 'text';
            } else if (currentRoom === 'music') {
                const urlLines = musicUrls.map(url => `[楽譜/URL]: ${url}`).join('\n');
                const lyrics = lyricsTextarea.value;
                content = `作者: ${nickname}\n\n[URL一覧]\n${urlLines}\n\n[歌詞/アイデア]:\n${lyrics}`;
                contentType = 'text'; 
            }

            const res = await fetch('/api/publish', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ 
                    title, 
                    room: currentRoom, 
                    content, 
                    content_type: contentType,
                    nickname: nickname 
                }) 
            });

            if (res.ok) {
                publishStatus.textContent = `作品「${title}」を公開しました！`;
                publishStatus.style.color = 'green';
                workTitleInput.value = '';
            } else {
                publishStatus.textContent = '作品の公開に失敗しました。';
                publishStatus.style.color = 'red';
                console.error('Publish failed:', await res.text());
            }
        });
    </script>
</body>
</html>